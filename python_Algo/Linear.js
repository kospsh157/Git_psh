//p173

// 입력으로 숫자 배열과, 타켓 숫자 하나가 주어지고
// 배열에서 임의 2개를 골라 더하면 target숫자가 되는 인덱스를 반환하면된다.
// 임의 2개는 반드시 한 쌍만 존재한다. 또한 배열의 원소에는 중복된 숫자가 들어갈 수 없다.

let twoSum = function(nums, target) { 
    let n = nums.length
    
    let map = new Map()
    for(let i=0; i<n; i++){
        map.set(nums[i], i)
    } 
    
    for(let i=0; i<n; i++){
        let temp = target-nums[i]
        if(map.has(temp) && i !== map.get(temp)){
            let arr = [i,map.get(temp)]
            return arr
        }
    }
}
// indexOf()는 최악의 경우 for문으로 다 돈것과 같다. 한마디로, 느리다.
// 배열에 중복된 숫자가 없다는게 중요하다. 그래야 map의 키로써 사용이 가능하다.
// has()함수를 사용해 target에서 nums의 원소들을 뺀 값이 키에 있는지 확인하는 것으로 약간 더 빠르게 구할 수 있다.
// has()함수는 O(1) 시간복잡도를 가지고 있다??

// 최적의 답안
var twoSum = function(nums, target) {
    let map = new Map()
    for (let i = 0; i < nums.length; i++){
        let r = target - nums[i]
        if (map.has(r)) {
            return [map.get(r), i]
        }
        map.set(nums[i], i)       
    }
};
// 찾고 > 넣고 다시 찾고 > 넣고      먼저 넣지도 않고 찾는것은 논리의 오류이다.
// 하지만 이 문제에서는 답이 한쌍이 존재하고, 한쌍중에 하나는 없어서 못찾았다 치더라도, 나중에 다른 하나에 의해서 다시또 검색될 수 있으니
// 효율성만 따진다면 배열을 다 만들고 거기서 찾는것보다 
// 위처럼 하나씩 먼저 찾고 >> 넣고 >> 찾고 >> 넣고 하는게 더 효율적이다.


// p180 빗물 트래핑
// 졸라 어려우므로, 일단 투포인트의 while문 의 원리부터 이해하자 
// 투포인트는 배열의 양끝 인덱스에서부터 시작해서 서로 번갈아가면 한칸씩 좌/우로 이동하면서 특정 로직을 수행하는 것이다.
// 0인덱스는 +1씩 하면서 오른쪽으로 이동
// arr.length-1 인덱스는 -1씩 왼쪽으로 이동
// 그러다가 어느 지점에서 멈추게되고, 로직을 끝나게된다.

// 핵심 조건은 2가지다. 
// 양끝에서 서로 동시에 움직이는게 아니라, 특정 조건이 성립되면 한쪽씩 움직이게된다.
// 예를들어 서로의 인덱스에 대응하는 원소값이 누가 더 큰지에 따라 왼쪽포인터 오른쪽으로 이동하던지,
// 오른쪽포인터가 왼쪽으로 이동하던지 하는 것이다. 그리고 이 조건이 문제에 따른 문제의 핵심조건이다.

// 남은 핵심조건 하나는 전체 while문 전제조건인데, 
// 투포인트 알고리즘 특성상 left 인덱스와 right인덱스가 변동된다.
// 따라서 while문을 left < right 이렇게 하면 서로 중복되는 인덱스없이 모든 인덱스에 대해서 한번씩 다 돈다.
// left나right인덱스는 while문 1싸이클을 돌때마다 둘 중 하나는 많거나 적어진다. 
// 즉 left < right 조건은 투포인트알고리즘을 쓴다면, 늘 있는 while문 전제조건이며, 문제에 따른 문제의 핵심조건이 아니다.

// 문제의 핵심조건이 되어야 하는 조건은 left와 right 인덱스중 누가 어떤 조건에 해당할 시에 누가 이동을 하냐이다.
// 이게 문제마다 로직을 다르게 해줘야할 핵심 조건이다.

// 이 문제의 핵심 규칙은 원소가 큰 정수에서 낮은 정수로 인덱스가 이동될때, 그 정수차이만큼 물이 쌓인다는 소리이다. 
// 그런데 계속 낮을쪽으로 이동하면서 쌓인 물의 높이를 재는데, 결국 반대쪽 벽이 없다면 그건 물이 쌓일수 없는 조건이므로,
// 항상 서로 반대쪽의 가장 높은 벽의 길이가 더 길어야 물이 쌓일 수 있으므로, 항상 서로 반대쪽 벽의 최고길이를 알아야한다.


let trap = function(arr){
    if(!arr){
        // 배열에 아무것도 없으므로 물을 받을 수 있는 양은 0이다.
        return 0
    }
    let volume=0
    let left = 0
    let right = arr.length-1
    let leftMax = arr[left]
    let rightMax = arr[right]

    // 첫 원소부터 최대값이 집어넣어서 인덱스가 움직일때마다 최대값을 검사해서 넣으면 
    // 논리적으로 항상 최대값을 얻을 수 있다.
    
    while(left < right){
        // 항상 좌/우로든 이동할때마다 큰 정수값으로 교체시킨다.
        leftMax = Math.max(leftMax, arr[left])
        rightMax = Math.max(rightMax, arr[right])
        
        // 서로 반대쪽으로 이동을 하되, 항상 최대값이 더크거나, 최소한 같은 정수여야한다.
        // 그래야 인덱스가 이동하면서 계산한 물의 양값이 진짜로 고일수있는 값이된다.
        if(leftMax <= rightMax){
            // 사실상 leftMax === rightMax 이면 어느쪽으로가든 상관없다 여기선 그냥 같으면 left인덱스가 움직이기로 한다.
            volume += leftMax - arr[left] // 높은쪽에서 낮은쪽으로 가되, 반대편 최대벽이 이쪽 최대벽이랑 최소한 같아야 물이 쌓인다.
            // 그리고 left인덱스는 오른쪽으로 한칸 이동
            left++
        }else{
            volume += rightMax - arr[right]
            right--
        }
    }
    return volume
}

