// << 현업에서 자주 쓰는 배열 관련 함수 >>
// 다음에 나오는 배열 조작 함수들은 매우 유용하게 자주 쓰이므로, 그냥 외워야 한다.

// join()
// 어떤 배열을 스트링타입을 바꿔서 그 문자열을 리턴하는 함수
// 즉 배열이 문자열이 된다.
// join() 안에 구분자가 들어가면 배열의 요소마다 그 구분자를 넣어서 문자열을 만든다
const arr = ['apple', 'banana', 'orange']
arr.join() // apple, banana, orange   // 구분자가 없으면 기본으로 "," 콤마를 요소마다 넣어서 문자열을 완성시킨다. 
arr.join('%')  // appple&banana&orange  가 리턴됨


// join과는 반대로 스트링타입을 배열로 바꾸는 함수
// split()
const string = 'abc, def, ghi'
const resultArr = string.split(',') // [abc, def, ghi] 스트링타입의 배열이 리턴된다.
// 주의할 점은 구분자가 콤마로 쓰였는데, 원본 문자열에 포함되어 있는 콤마 단위로 요소를 나누어서 배열로 만든다는 뜻이다. 
// 원본 문자열에 없는 구분자로 할 수 없다. 
// 원본 문자열에 없는 구분자를 인자값으로 줄 경우 인자값이 없는 걸로 받아들여져서 그냥 통으로 요소하나인 배열이 나온다.
string.split(',' , 2) // 두 번째 인자로 2를 주게되면 구분자로 구분되어 생성된 요소중에 2번째까지만 불러서 배열을 만들고 리턴한다. 
// 따라서 ['abd', 'def'] 가 리턴된다.


// 배열의 순서를 거꾸로해서 다시 배열을 만들기
// reverse()
const arrNum = [1,2,3,4,5]
const resultReverse = arrNum.reverse() // [5,4,3,2,1] 로 배열이 리턴된다. 
// 주의 할 점은 원본 배열인 arrNum도 리버스된다. 따라서 이점을 유의해서 써야 한다.


// 배열의 인덱스값으로 배열 짜르기
// splice()
const arrTest = [1,2,3,4,5]
arrTest.splice(0, 1)  // 0번 인덱스부터 1개 지우기 >> [2,3,4,5] 만 남는다. 리턴되는 값은 [1]
arrTest.splice(3, 2)  // 3번 인덱스부터 2개 지우기 >> [1,2,3] 만 남는다.   리턴되는 값은 [4,5]
arrTest.splice(2, 2)  // 2번 인덱스부터 2개 지우기 >> [1,2,5] 만 남는다.   리턴되는 값은 [3,4]
// 주의 할 점은 원본 배열의 상태과 리턴값이 다른다는 거다.
// 위에서 arrTest는 스플라이스를 당했다. 그러므로 짤려서 짤린 부분만 남는다.
// 반면 스플라이스함수로 리턴되는 배열은 짜른 요소들의 배열이다.
// 또 주의할 점은 자세히 생각해보면 이 스플라이스 함수는 원본 배열을 수정하는 함수이다. 즉 새로운 배열을 만들어서 리턴해주는게 아니다. 
// 하지만 만약 원본을 수정하지 않고, 원본을 토대로 새로운 배열을 리턴받고 싶다면, 스플라이스함수보단 슬라이스함수를 써야한다.

// 배열 짜르기2 
// spilce() 
// 첫 번째 인자로 시작인덱스를, 두 번째 인자로 끝나는 인덱스지점을 받는다.
const arrTest2 = [1,2,3,4,5,6]
const newArr2 = arrTest2.slice(1,3) // 인덱스 1부터 3까지 짤라서 새로운 배열로 리턴한다. (= 원본 배열을 수정하지 않는다)
// 주의할 점은 인덱스의 포함범위이다. 1인덱스는 포함하지만 3인덱스까지 포함되어서 나오지 않고 2인덱스까지만 짤려서 나온다. 
// 즉 위의 반환 배열은 [2,3] 이다  두번째인자로 받는 끝인덱스지점까지 포함되어서 나오지 않는다. 시작지점은 포함되어서 나오는데
// 왜 이렇게 햇갈리게 만들었는지 모르겠지만 그냥 외워야한다. 외우자.


// << 아주 유용한 배열 관련 콜백 함수 >> 
// 배열에서 어떤 조건이 만족될 때 그 조건을 만족시키는 요소를 바로 리턴하는 함수 
// find()
// find()는 인자값으로 콜백함수를 받기 때문에 콜백함수를 써야한다. 그리고 그 콜백함수의 내용이 어떤 찾고자 하는 조건이다.
// 어떤 배열의 각 요소마다 콜백함수를 호출해서 조건이 맞는 요소들이 있는지 검색한다. 만약 해당 요소를 찾게되면 바로 검색을 중지하고 그 요소를 리턴한다.
// 콜백함수의 인자로 (this, value, index, obj) 이렇게 4개 인자가 들어오는데 여기서 this와 obj는 사실 뭔지 잘 모르겠어서 설명하지 못하겠다.
// 주로 value, index 를 쓰는데, value는 배열의 요소하나하나를 의미하는 거고, index는 말그대로 인덱스다;

// 주의 할 점은 find() 는 해당 조건에 맞는 요소를 리턴하고 find()가 쓰는 콜백함수는 논리값을 리턴해야한다는 소리이다. 
// 다시 정리해서 말하자면, 콜백함수안에 일정 조건문이 들어가있고, 그 조건문에 의해 true / false 값을 콜백함수가 리턴하고, 만약 true가 리턴되면
// 그 즉시 find()함수는 해당 요소를 리턴하고 함수는 종료된다.


// 지금은 배열의 요소들이 단순하지만 사실 배열의 요소값을 객체가 오는 경우가 많다. 
let obj1 = {
    name: 'Chul-su',
    old: 30
}
let obj2 = {
    name: 'tan-il',
    old: 23
}
let obj3 = {
    name: 'bae-sun',
    old: 44
}
const objArray = [obj1 , obj2, obj3]
// 위와 같이 배열이 있을 때 배열의 요소들 중에서 나이가 30인이상인 것과 그 인덱스를 가지고 있는 요소(여기선obj객체)를 굳이 find() 함수를 써서 찾는다고 하자 (굳이라는 표현은 부정적인 뜻으로 쓴게 아님)
const findOlder = objArray.find(function(value){ // 인자값으로 value하나만 사용
    return value.old >= 30  // 주의할 점은 콜백 함수가 true / false 를 반환하겠금 만들어야 하다는 것이다. 
    
    // 여기서는 각 요소(obj객체)의 old프로퍼티 하나하나 접근하여 30이상이면 true 아니면 false를 반환하게 만들었다.
    // 반환값이 true일 경우 그 즉히 함수가 종료되고 해당 요소가 리턴됨을 잊지말자
    // 반드시 return 키워드로 true or false를 리턴하게끔 만들어야 한다.
    // 또한 true를 받게되면 그 즉시 함수가 검색을 종료하고 해당 요소를 리턴하기 때문에 조건에 맞는 딱 하나의 요소만을 찾을 수 있다는 사실을 잊지 마라.
})
// 위를 화살표함수로 바꿔서 표현하면
const findArr = objArray.find((value) => value.old >= 30) // 한줄일 경우 {}, return 키워드를 생략할 수 있다.



// find는 하나의 요소만 찾을 수 있다. 조건에 맞는 여러개의 요소를 찾아 조건에맞는 요소만으로 배열을 새롭게 만들려면 어떻게 해야할까
// filter()
// 필터는 굉장히 자주 쓰는 함수이다. 파인드함수와 마찮가지로 콜백함수를 이용한다
const filterArr = objArray.filter((value) => value.old >= 30)
// 파인드와 작동방식이 똑같다 다만, 필터함수는 조건을 찾아도 계속해서 배열의 끝까지 조건에 더 맞는 요소가 없는지 검색한다.
// 파인드는 하나를 찾는 즉시 해당 요소를 그냥 반환하지만, 
// 필터는 조건에 맞는 모든 요소를 찾아 배열로 완성시켜 그 배열을 리턴한다. 
console.log(filterArr) //[ {name:"Chul-su", old:30}, {name:"bae-sun", old:44} ] 출력, 나이가 30 이상인 모든 요소를 찾아 새롭게 배열을 만들어 배열을 리턴한다.




// map()  맵핑함수 
// 맵핑이란, 어떤 규칙으로 각각 어떤것과 어떤것을 매칭시키는 것이다. 
// 여기서는 이 맵핑이란 개념을 좀 더 넓게 확장해서 어떤 원본 배열의 요소들을 내가만들 규칙으로 새롭게 바꿔 새로운 배열을 만들고 이 둘을 맵핑시키는 것이다.
// 뭔가 개념적으로는 햇갈릴수있다. 그냥 나만의 규칙으로 원본 배열을 이용해 새로운 배열을 만든다고 생각하자, 코드와 예시를 보면 감이 온다.
const mappingArr = objArray.map((value) => value) // 이렇게하면 콜백함수에서 아무 규칙을 가하지 않고 원본 그대로 다시 리턴한다. 
console.log(mappingArr) //  == console.log(objArray) 의 출력값과 똑같다.
const mappingArr2 = objArray.map((value) => value.old - 10) // 각각의 요소의 old프로퍼티마다 10를 마이너스해서 그 프로퍼티만을 가지고 새로운 배열을 만든다. 
// 나만의 규칙으로 새롭게 가공한것이다.
console.log(mappingArr2) //  [20,13,34]가 출력된다. 원본배열의 각각의 요소의 프로퍼티인 old만을 가공해서 새롭게 old만 들어있는 배열이 리턴된다.
// 이 맵핑 함수를 잘 이용하면 정말 많을 곳에 이용될 수 있으니 반드시 외워두자



// some(), every() 함수
// 마찮가지로 둘 다 콜백함수를 이용한다. 
// some()은 어떤 배열에 내가 원하는 조건의 요소가 하나라도 있으면 true, 없으면 false 리턴하고
// every()은 어떤 배열에 내가 원하는 조건이, 모든 요소가 충족해줘야지만 true, 한개의 요소라도 내가 건 조건에 맞지 않으면 false를 리턴한다.
const someArr = objArray.some((value) => value.old > 30) // 각각의 요소마다 old프로퍼티가 30이 넘는지 확인하다가 30이 넘는것을 찾으면 그 즉시 종료되고 true리턴
const everyArr = objArray.every((value) => value.old > 30) // 모든 요소를 하나씩 다 체크해서 각각의 요소의 old프로퍼티가 모두 30이 넘어야만 true리턴
console.log(someArr) // true 리턴   // 30를 초과하는 요소가 하나이상 있으므로 true 리턴 
console.log(everyArr) // false 리턴 // 모두 다 나이가 30초과가 아니다. 따라서 false를 리턴한다.
// 주의할 점은 리턴요소가 논리타입이라는 것. 
// find()함수를 사용해서 비슷하게 같은 목적을 해결할 수 있지만, find()는 요소를 리턴하고
// some(), every()는 심플하게 논리타입을 리턴한다는 점이 상황에 따라 어떤걸 써야 조금이라도 더 편하고 간단하게 코딩할 수 있다는 점을 알아두자.


const reduceArr = objArr.reduce((prev, curr)=> console.log(prev, curr))
 // redureducece() 
 // 주로 배열의 요소가 다 숫자이고 배열의 요소들을 전부다 합산시켜서 뭔가를 할 때 쓰는 함수이다. 
 // 이해하기 좀 난해할 수 있다 미리 겁먹어라. 
 // 역시 콜백함수를 사용한다.
 // 지금까지 배열 지원 함수에서 콜백함수가 작동했던 방식을 기억해라. 주어진 배열의 각 요소마다 콜백함수가 마치 반복문처럼 1싸이클씩 돈다. 
 // 따라서 주어진 배열이 [10,20,30] 이라면 콜백함수는 value에 10부터 넣고 콜백함수 한 번 작동하고(이게 1싸이클이라고 치자) 
 // value에 20을 넣고 한 번 더 콜백함수가 작동되고 (이게2싸이클)
 // value에 30을 넣고 한 번 더 콜백함수가 작동해서 이렇게 총 3싸이클을 돌고 종료하는 것이다. 
 // 작동 방식은 이렇다. 그냥 순서대로 이해하면서 읽어주기 바란다.
 /*
    1. reduce(function(prevValue, currentValue){}) 방식으로 쓰이고 인자값은 원래 더 많은데 그냥 2개만 설명하겠다. 나머지는 모른다. 그리고 주로 이렇게 2개만으로 쓴다.
    2. 파라미터이름이 prevValue, currentValue 이다, 이전요소값, 현재요소값 정도로 풀이가 되는데, 이런 이전/현재 시간개념이 이 함수의 설명에 도움이 되는지 난 잘 모르겠다.
    3. 아무튼 이제 설명의 편의상 "콜백함수(prev, curr)" 이렇게 콜백함수를 표현하겠다.
    4. 우선 첫번째 콜백 사이클에는 prev, curr에 배열의 인덱스값 순서대로 0번째 요소, 1번째 요소가 들어간다. 
    5. 배열이 만약 [10,20,30,40,50] 라면 첫번째 사이클에 10과 20이 각각 prev, curr으로 들어간다는 소리이다.
    6. 두 번째 콜백 사이클에는 콜백함수(prev, curr)에 각각 Undefined와, 30이 들어간다. 
    7. 두 번째 사이클에서 부터 이상하다. 왜 이전값(prev)에 아무런 값이 할당되지 않을까? 그리고 현재값(curr)에는 예상대로, 차레대로 그 다음 요소인 30이 들어갔다.
    8. 두 전째 사이클부터 이전값이 이상한 이유는 바로 사용자가 콜백의 리턴값을 이용해서 이전값이 뭔지 정해줘야 하기 때문이다. 
    9. 지금 설명할때는 당근 내가 콜백함수의 리턴값을 지정해주지 않았으니 2번째 사이클 부터는 계속 이전값이 Undefined로 나온다.
    10. 3번째 싸이클에는 이전값에 Undefined, 현재값에 40이 들어간다. 이러다가 결국 현재값에 50이 들어가면 총 싸이클 4번으로 콜백함수를 4번 호출하고 reduce()함수는 종료된다.
    11. 여기서 핵심1번: 2번째 사이클부터 그 전 싸이클에서 리턴한 값을 prev넣고 콜백함수를 돌린다.
    12. 핵심1번에 의하면 내가 만약 콜백 리턴을 curr으로 하면 1싸이클에서 curr값이 리턴되고 그 curr값이 prev값이 되어서 2사이클에서 돌아간다는 소리이다.
    13. 이렇게 콜백리턴을 curr으로 했다고 치고 돌려보면 1싸이클에서 10,20넣고 돌리고 2싸이클에서 20,30넣고 돌리고, 3싸이클에서 30,40넣고 콜백함수돌리고, 또 4싸이클에서 40,50넣고 돌리고 종료된다.
    14. 그리고 한가지 더 설명을 안한것이 있는데   reduce(function(prevValue, currentValue){}) 에서 리듀스 첫번째 인자값이 콜백함수이다. 그리고 두번째 인자값을 넣어줄수 있다.
    15. 리듀스함수에 2번째 인자값까지 사용하면 이런 모습이 된다. reduce(function(prevValue, currentValue){}, 0)
    16. 내가 두번째 인자로 0을 쓴 이유는 이 두번째 인자값을 쓰게되면 1싸이클에서 prev값이 0으로 되기 때문이다. 즉 두번째 인자값은 처음부터 아예 1싸이클의 prev값을 지정해주는 역할인것이다.
    17. 그럼 reduce(function(prevValue, currentValue){}, 0) 의 싸이클을 어디 알아보자
    18. 1싸이클에서 콜백(prev, curr) 은 이렇게 될것이다 콜백(0, 10) prev값을 지정해주었으므로, 순서대로 curr에 요소첫번재인 10부터 들어간다.
    19. 2싸이클에서 콜백(10,20)이렇게 작동된다. 이유는 앞에서 설명했듯이, 1싸이클에서 리턴값으로 curr을 설정했기 때문이다. 
    20. 3싸이클에서 콜백(20,30)이렇게 넣고 작동되고... 4싸이클에서 콜백(30,40) 마지막으로 5싸이클에서 콜백(40,50) 까지 돌고 종료된다.
 */

 // 다음의 코드를 직접 수정해보면서 출력해보면서 공부하면 이해가 될 것이다.
const arr1 = [10,20,30,40,50]
const reduceArr2 = arr1.reduce(function(prev, curr){
    console.log("시작")
	console.log(prev)
    console.log(curr)
    console.log("끝")
    return curr
},0 )

// 근데 중요한점을 잊고있었다 그래서 결국 reduce()함수가 최종적으로 리턴하는 것은 무엇이냐? 
// 위의 코드대로 보면 마지막 리턴했던 curr의 요소값. 즉 50이다.
console.log(reduceArr2) // 50
// 하지만 이렇게 쓰면 아무의미없다. 대체적으로 값을 누적시키서 쓰는걸로 사용한다. 
let obj11 = {
    name: 'Chul-su',
    old: 30
}
let obj22 = {
    name: 'tan-il',
    old: 23
}
let obj33 = {
    name: 'bae-sun',
    old: 44
}
const newObjArray = [obj11 , obj22, obj33]
// 위와 같이 있을 때 배열의 요소중에서 old프로퍼티를 누적시켜서 리턴받고 싶다. 할 때 쓴다. 
const sumOld = newObjArray.reduce((prev, curr) => prev + curr.old ,0)   
console.log(sumOld) // 97 

// 위의 화살표 함수를 풀어서 쓰면
const sumOld = newObjArray.reduce(function(prev, curr){
    return prev + curr.old
}, 0)

// 처음 0부터 시작하고 계속해서 첫번째 요소의 old프로퍼티를 더하고 
// 또 다음 싸이클에는 첫번째사이클에서 나온 합에다 두번째요소의 old프로퍼티를 더하고.. 
// 계속 이렇게 누적하는 방식으로 덧셈을 하게된다. 그래서 배열 전체요소의 old프로퍼티의 합을 리턴한다.
// 솔직히 이거 읽고 reduce()함수 이해 했다면 당신을 스스로 칭찬할 필요가 없다.
// 이걸 읽고 이해했다면 내가 설명을 잘한것 뿐이다.
// 직접해보지 않는 이상 이해하기 힘든 함수이다...




// 위에서 배운 것들 몇개만 같이 합쳐서 써보자 
let obj01 = {
    name: 'Chul-su',
    old: 30
}
let obj02 = {
    name: 'tan-il',
    old: 23
}
let obj03 = {
    name: 'bae-sun',
    old: 44
}
let obj04 = {
    name: 'du-san',
    old: 14
}
let obj05 = {
    name: 'han-hwa',
    old: 50
}
let obj06 = {
    name: 'en-cci',
    old: 80
}
const newObjArray1 = [obj01 , obj02, obj03, obj04, obj05, obj06]
// 위의 배열을 이용해서 30살 이상인 사람의 나이만 있는 배열을 문자열로 바꿔서 리턴해보자

const whatUwantValue = newObjArray1.map((value)=>value.old).filter((value)=>value >= 30).join()
console.log(whatUwantValue)  // "30,44,50,80" 문자열로 리턴되었음을 주의

// 보기 좋게 풀어서 쓰면 
const whatUwantValue = newObjArray1
    .map((value)=>value.old)
    .filter((value)=>value >= 30)
    .join()
// 코딩할 때는 이렇게 보기 좋게 풀어서 쓰자.

// 또한 파라미터 이름도 지금 다 value로만 했는데 실제 직장에서 코딩을 할때 직장에서 파라미터이름을 어떻게 써야하는지 가이드라인이 있다. 그대로 맞춰서 써야 보기가 더 좋다.
// 위의 코드는 파라미터이름을 다음과 같이 바꾸면 더 알아보기 좋을 것 같다.
const whatUwantValue = newObjArray1
    .map((person)=>person.old)  //  각각의 사람들의 요소에서 나이만 빼서 나이로 새로운 배열을 만들어 리턴  // [30,23,44,14,50,80]
    .filter((old)=>old >= 30)   //  그 나이로만 있는 배열에서 30이상만 추려서 새로운 배열을 만들어 리턴   // [30,44,50,80]
    .join()                     //  해당 배열을 통으로 하나의 문자열로 만든다                           // '30,44,50,80'


