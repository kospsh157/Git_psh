// 링크 단계
/*
    1. 입력으로는 여태것 나온 오브젝트 코드들을 모두 입력한다. 
    2. 링커라는 놈이 링크단계를 수행함
    3. 출력으로는 구멍을 메꾼 뒤 실행파일로 나온다.
    
*/



// 함수나 변수의 정의 부분을 못찾는다면
/*
    1. 구멍을 메꿔야할 코드 정의부분을 못찾는다면 링커가 못 찾는다고 링커 오류를 뱉는다.
    2. 그 함수나 변수가 없어 실행할 방법이 없기에 경고가 아니다 오류를 뱉는다.
    3. 오류 내용은 다음과 같다
    파일이름 : error LNK2019:unresolved external symbol _add referenced in function _main
    ... 생략 

    찾을 수 없는 외부 심볼이 있다. _add라는 함수가 _main에 쓰여져있는데 그걸 찾을 수 없어서 더이상 못하겠다. 이런 뜻임
    선언부만 있고 구현부가 없기때문에 일어난 오류이다.

*/
 

 
// 왜 컴파일 3단계와 링크 단계를 분리해서 하는지
/*
    1. .c파일이 많이 있으면 구멍 메꿔주는 일이 매우 복잡해짐
    2. 동일한 외부 함수를 사용할 경우, 만약 컴파일3단계 마다 참조 주소로 가서 해당 함수의 정의를 복붙할경우
    계속해서 똑같은 작업을 반복하게 된다. 그리고 그 함수 역시도 같은 함수이다. 따라서 나중에 한꺼번에 한번만 하는게 효율상 더 좋다.
    3. c파일을 한번에 합쳐서 컴파일하면 되지 않는가? 
        1. 이렇게되면 코드 한줄을 수정해도 엄청난게 많은 수의 코드를 다시 컴파일해야한다. 
        2. 결국 분리해서 따로따로 오브젝트파일로 저장해두는 방법이 낫다. 

    4. 
*/


// 실무에서 빌드 과정
/*
    1. 가장 많이 쓰는 방법은 오브젝트 파일까지 컴파일을 하고 다시 오브젝트 파일들을 모아서 exe 실행파일로 링커 작업을 하는 식으로 한다.
    2. 가장 많이 쓰는 ide툴인 비주얼스튜디오에서도 이런식으로 2단계로 나눠서 빌드를 한다.
    3. clang에서는 바로 바로 exe로 나오므로 단계별로 하고 싶다면 이렇게 하면된다.
    clang -std=c89 -W -Wall -pedantic-errors main.o adder.o  // 이렇게 모든 오브젝트 파일을 추가시켜준다.
    clang -std=c89 -W -Wall -pedantic-errors *.o             // 이렇게 그냥 모든 오브젝트파일을 다 링크걸어줘라 할 수도있다. 

*/