
// 클래스가 없다 씨는!

// 클래스가 없으므로 접근제어자(public, private ..) 없다.

// 함수 오버로딩 그런거 없음

// 씨는 항상 위에서 아래로 순서대로 컴파일 하기 때문에 만약 정의도 되지 않은 함수를 호출하면, ( conflicting types for '함수이름' 에러)
// 기본값으로 반환형int, 매개변수 아무거나 올수있음 으로 가정해서 함수를 지가 작성한다.
/*
    위와 같은 현상때문에 함수가 많아지고 함수끼리, 호출을 할때 마다 순서를 생각해서 위에서 다시 함수정의 위치를 바꿔줘야한다.
    이는 매우 불편하기 짝이없는 현상이고 이에 대한 방법은 다음과 같다.

    함수를 정의하지 않고, 선언만하는것 
    이게 무슨말이냐면 구현부분 {} 이 부분을 작성하지 말고 
    1. 함수이름
    2. 반환형
    3. 매개변수들의 자료형
    이 3개만 작성하는게 선언만 하는 것이다. 

    즉 제일 위에 선언( 이를 전방 선언 이라고 한다.) 만 하고 밑에서 정의를 다시 하는 것이다. 
    따라서 모든 함수는 전방선언으로 해줘야 한다. 씨에서는 이렇다. 어쩔 수 없다.
    

*/
int main(void){
    get_sum();   // 이렇게 호출해버리면 컴파일러는 그냥 기본값 함수를 만듬. (c99 부터는 또 다름 그러니 그냥 이렇게하지말자)
    return 0;
}

int get_sum(int a, int b){
    return a + b;
}
// 위 코드는 컴파일 에러가 일어난다.


int main(void){
    int sum = get_sum(4, 2);
    return 0;
}
int get_sum(int a, int b){
    return a + b;
}

// 위는 컴파일 에러가 나지 않는다. 하지만, 전방선언을 해주는게 표준 코딩법이다.




// 매개변수에 아무것도 오지 않으면 반드시 void 로 명시해주는게 좋다.



// 다음과 같은 함수를 매개변수로 가지고 있는 함수가 있다. 이를 실행하면 어떤 함수가 먼저 평가되어질까?(호출될까?)
printf("%d, %d\n", add(num1, num2 ), subtract(num1, num2));
/*
    답은 unspecified, 
    표준이 명시되어 있지 않다. 뭐가 먼저 호출될지 모른다.
    
    보장되는 것은 단지 printf 가 실행되기 전에,  add(), subtract() 가 호출된다는 것은 보장

    이 문제가 실제로 코딩을 하다보면 예기치 않은 오류를 발생시킬 수 있다.
    
    위에 예시로 든 add(), substract() 두 함수는 서로 관계가 없는 함수끼리라 상관없지만 
    만약에 두 함수가 서로 관계가 있어서 add() 함수가 먼저 작동을 해야 substract() 함수가 어떤 조건이 성립되어 발동한다고 치면 
    둘 중에 뭐가 먼저 호출될지 모르니, printf()함수는 원하는데로 작동하지 않을 것이다. 이 점에 대해서 주의해야한다. 

    이러한 오류를 피할려면 두 함수를 두 줄에 따로 호출하는 것밖에 없다. 

    이러한 순서 관련을 시퀀스 포인트라고 한다. ; 세미콜론은 명백한 시퀀스포인트 중에 하나이다. 
    int a; int b; 하면 반드시 int a를 평가를 하고, 그 다음 int b를 평가한다. 이렇게 순서가 확실하다. 

    
*/




// 오류 정리 
/*
    1. unspecified 오류는 위험한 오류는 아니다. 컴파일러에 따라 순서가 어떻게될지 몰라, 결과가 다르게 나온다는 것이다.
    2. undefined behavior 오류 이거는 위험하다. 무슨 일이 일어날지 모른다. 
    
    1. 은 최소한, 컴파일러에 따라 서로 다른 경우의 수 정도는 지정되어 있다. 하지만 어떤 경우의 수가 나올지는 모른다.
    2. 동시에 평가될 수도 있다. >> 쓰레드가 동시에 자원을 잡고있는 현상 >> 비트연산이 꼬이게된다. 
    즉 함수 매개변수의 평가 순서는 컴파일러마다 다르고, 
    한 함수의 매개변수들이 동일한 변수를 수정할 경우, 결과가 위험하다. 정의되어 있지 않다.  

    * 기본적으로 한 줄에서 동일한 변수를 여러번 바꾸면 위험하다!!!!
    
    add( ++i, ++i); 어떤일이 일어날지 정의되어 있지 않음
    add( i = -1, i = -1); 어떤 일이 일어날지 정의되어 있지 않음
    add( i, i++); 어떤 일이 일어날지 정의되어 있지 않음

    

    비트연산이 꼬이기 때문에 위의 3가지 경우 모두 어떤일이 일어날 지 모른다. 

    매개변수나 연산자가 시퀀스포인트가 아닐때, 이런일이 일어난다. 
    만약 연산자가 순서를 강제하는, 시퀀스포인트가 있다면, 순서가 정해지기 때문에 이런 일이 일어나지 않는다.
    하지만 대표적으로 많이 쓰이는 연산자 +, = 는 시퀀스포인트가 없기 때문에 주의해야 한다. 
    
    i = ++i + i++; 
    i = i++ + 1; 
    array[i] = i++; 
    위의 3개도 모두 역시 어떤일이 일어날지 모른다. 따라서 주의하자
    
*/
 

