// 배열의 요소 개수 구하는 방법

/*
    1. sizeof() 로 일단 배열의 총 용량을 구한다. (byte 단위로 나온다.)
         sizeof()로 총용량을 구할 수 있는 이유는 컴파일 단계에서 이미 컴파일러가 배열의 총 용량을 알고 있기 때문이다. 
         
    2. 그리고 총 용량을 sizeof(array[0]) (=원소 하나의 용량을 구해서) 원소하나의 용량으로 나눈다.
    3. 그러면 총 몇개의 원소가 있는지 알 수 있다.

*/

// 원리 
const size_t num_vals = sizeof(value) / sizeof(value[0]);

// 실사용
#define ARRAY_LENGTH(arr)  (sizeof(arr) / sizeof(arr[0]))  // 나중에 매그로 함수 배우면 알 수 있음
const size_t num_vals2 = ARRAY_LENGTH(values);



// 매개변수에 들어가는 배열에 대해서 sizeof() 는 실제 그 배열의 크기에 상관없이 4바이트를 반환한다. (즉 실제 사이즈를 알 수 없다.)
/*
    1. 이걸 이해할려면 함수의 스택 메모리 호출 과정을 알아야한다.
    2. 스택에서 똑같은 함수가 호출되면 매개변수에 상관없이 항상 같은 크기의 스택을 차지한다.
    3. 스택은 크기가 작기 때문에 서로다른 매개변수마다 일일이 다 다르게 할 수 없다. 
    4. 따라서 배열이 들어올 경우 배열을 그대로 복사해서 스택에 담는게 아니라, 그 배열의 시작점 위치, 즉 배열의 메모리 주소를 담는다.
    5. 대부분 주소는 포인터 데이터형이고, 
        1. 32비트 플랫폼에서는 포인터 데이터형의 크기는 4바이트,
        2. 64비트 플랫폼에서는 포인터 데이터형의 크기는 8바이트 이다.
    6. 따라서 모든 매개변수의 배열에 sizeof()를 하면 32비트 컴퓨터에서는 4바이트가 나오는 것이다. 어차피 주소만 들어가기 때문에 
    큰 용량을 필요로 하지 않기 때문이다. 
    7. 매개변수 배열의 길이를 알 방법은 절대 없다.
*/

// 매개변수의 배열의 길이를 알 방법이 없으니 코드는 이렇게 작성해야 한다.
void process(size_t n, int nums[]){  // 배열의 길이 n을 정해서 같이 집어넣어준다. 
    size_t i;
    for(i=0; i<n; ++i){
        nums[i] *= 2;
    }
}








// 어떤 함수에 매개변수로 배열을 넣으면 >> 그 함수에 작동에 따라 원본 배열이 바뀐다. 
/*
    1. 함수에 매개변수로 배열이 올 때 무조건 참조값(주소값)으로 온다고 했다. (int, float, double 이런애들은 값복사가 된다.)
    2. 따라서 그 함수에서 매개변수로 들어온 배열에 뭔가 조작을 가하면, 무조건 원본배열이 바뀔 수 밖에 없다. 주소값을 이용해서 실제 그 원본배열로 이동하면서 작동하니깐.
    3. 이런 현상을 '참조의 의한 호출' 이라고 말하기도 하는데 중요하지 않다.
    4. 중요한 것은 주소값이라도, 일단 복사를 해서 함수 스택메모리에 집어 넣었다는 뜻이다. 그게 실제 값은 아니지만 주소값을 '복사'해서 넣었다.
    5. 씨에서 모든 포인터는 주소값을 가지고 있고, 그 주소값을 복사해서 가져온다. 따라서 '값복사'라고 해도 된다.
    6. 이런 표현은 오히려 햇갈리기만 한다. 따라서 실제로 어떻게 작동하는지 그 원리만 제대로 이해한다.
    7. 더 중요한 점은 원본이 바뀌냐? 사본이 바뀌냐? 이다.
*/






 // 스택의 쓰레기값 & 배열 요소의 초깃값에 대해서
 /*
    1. 씨는 가비지컬렉터가 없다. 그래서 다쓴 함수공간을 반환하지만, 그렇다고 그 공간에 있는 쓰레기값을 지워주진 않는다.
    2. 따라서 내가 그 공간에 또 다른 함수를 호출할 수 있는데, 그 경우 쓰레기값위에 내 함수가 호출되는 것이다.
    3. 만약 내가 쓰레기공간에 배열을 int nums[30]; 을 잡았다고 하자, 그럼 어떻게 되는가? 
    4. 씨는 배열의 초깃값을 잡아주지 않는다. 따라서 쓰레기값이 담겨있고, 속에 뭔 값이 들어있는지 모른다는 것이다.
    5. int val; 그냥 지역변수를 할 때도 마찬가지이다. 지역변수도 스택에 담긴다. 초기화를 안해주면 저 변수에 뭐가 있는지 알 수 없다.
    6. 

 */


// 배열의 초기화
/*
    1. int nums1[4];                    // 쓰레기만 잔뜩
    2. int nums2[4] = {10, 15, 3, -1};  // 모두 초기화 됨 
    3. int nums3[4] = {10, 15};         // 10, 16, 0, 0 으로 초기화됨. 즉 값이 할당되지 않는 부분은 0으로 됨
    4. int nums4[2] = {10, 15, 3};      // 당연히 컴파일 오류
    5. int nums5[] = {10, 15, 3};       // 배열의 크기를 처음부터 안잡고 값할당으로 잡았으므로 컴파일러가 알아서 잘 배열의 크기를 3으로 결정한다.
*/


// 위의 3번 특징을 이용한 배열 초기화방법
int nums[10] = {0, };      // 전부다~~ 0으로 초기화 된다. 콤마를 안찍어도 작동은 되지만, 사람이 보기에, 햇갈릴 수 있으므로 콤마를 찍어준다.


// 배열 사용시 주의점 
/*
    1. 초기화 안된 지역 변수를 모른 채 사용할 수 있음
    2. 버퍼 오버플로도 가능
        버퍼 오버플로우란 매우매우 자주 할 수 있는 실수인데, 컴파일러가 잡지도 못하고 프로그램을 잘 돌지만 제대로 돌고 있는 않은 상태의
        아주아주 위험한 상태이다. 
*/
// 버퍼 오버플로
int buffer[2] = {2,2};
int buffer2[2] = {1,1};
size_t i;

for(i=0; i<=2; ++i){  // 실수의 시작은 여기 i < 2로 해야하는데 i <= 2로 해서 포문이 2번만 돌아야하는데 3번돌게되는 것
    buffer2[i] = 0;
}

// 위 포문의 의도는 buffer2에 할당받은 메모리 공간에만 가서 전부 0으로 고치라는 것인데,
// 문제는 포문이 한 번 더 돈다. 그리고 buffer2[2] 라는 공간은 없지만 다른 영역을 침범해서 그 공간에 0을 복사한다.
// 그리고 하필 침범 영역이 buffer[] 영역일때, 너는 의도치 않게 buffer[]의 원소값 하나를 0으로 바꾸게 된것이다. 
// 이게 바로 버퍼 오버플로이고 memory stomp 라고도 한다. 이는 c / c++ 를 할 때 가장 고치기 힘든 버그중에 하나이다.









