// size_t형에 대해서

/*
    1. 사실 이녀석은 부호없는 정수형이나 실제 데이터형이 아니다.
    2. _t 라는 것은 >>> 따른 데이터의 별칭 같은 것이다.  >> 이걸 왜 쓰느냐? >> 중요한것은 어떤 데이터의 크기를 나타내기 위해 탄생된 별칭이란 것이다.
    3. 그럼 size_t의 최소 단위는? >>> c99 표준에서는 최소 16비트를 요구함 >>> 2의16승 -1 = 65535 는 되어야 한다는 소리.


    4. size_t 의 존재 이유는 씨언어의 특성때문에 생겼다.
    씨언어는 데스크탑에만 있는 것이 아니다. 임베이드 언어이다. 따라서 어떤 기기를 만날 지 모르고,
    기기 마다 최상의 사이즈 표현법이 조금씩 다르고 환경도 다를 것이다. 그래서 생겨난 것이다. 

    5. 참고로 _t 는 typedef 를 했다는 힌트이다. 
     
*/



// size_t의 용도
/*
    어떤 것의 크기를 나타내기 위해 사용
    좋은 예 : 반복문이나 배열에 접근할 때 사용 
        반복문의 카운터 변수에 음수가 필요없을 때
        배열의 경우 길이가 음수가 될 수는 없으니.. 
        (기본적으로 unsigned short 라고 생각하면 되므로.. unsignded short 가 쓰일 수 있는 곳은 모두 다 쓰일 수 있다.)

    일반적으로 현재에서는 그냥 unsigned int 처럼 사용한다. 

*/





int int_array[30];
size_t i;

for (i=0; i < 30; ++i){
    int_array[i] = i;   // >> 이런 배열의 인덱스에는 음수가 필요 없으므로, 이런 경우에 자주 쓴다.
    // 근데 위에부분은 i가 배열의 인덱스로만 쓰인게 아니라, 값으로 i도 들어간다.
    // 하지만 굳이 따지자면 i는 현재 unsigned int 이고   int_array의 값은 int로 선언되어 있다.
    // 이 부분이 약간 안 맞는다. 
} 


// 다만 예외가 있다. 
/*
    signed int의 -1과 unsigned int 최댓값은 같은 비트 패턴을 가진다.
    둘다 비트패턴으로는 1111 1111 1111 1111 1111 1111 1111 1110 으로 서로 같다. 
    이를 이용해서 site_t 최고값이 나오면 그걸 예외인 -1로 보겠다 라는 함수를 작성해서 사용해도 된다. 
*/


// 배열의 크기가 동적이다?!!
/*
    배열의 경우, 함수 인자로 받을 경우 다른 결과가 나옴
    나중에 배열을 배울 때 왜 그런지 알 수 있다. 배열 부분으로 가라

*/

size_t get_char_array_size(char data[])
{
    return sizeof(data);
}

int main(int argc, char** argv){
    char char_array[30];
    
    size_t size_array = sizeof(char_array);                     // 30 바이트
    size_t size_array2 = get_char_array_size(char_array);       // 4 바이트

    return 0;
}

