/*
    팀이 L개 존재한다.
    공연은 연속된 최소 L일 이상 해야한다.
    공연장의 N개의 숫자로 비용들의 배열이 주어진다.
    
    입력 첫 줄에는 케이스의 수 
    두 번째 줄에는 N과 L이 입력된다.
    세 번째 줄에는 N개의 공연장 비용이 주어진다.

    

    <알고리즘을 훈련하는 목적 : 문제해결 능력을 키우기 위해서>
    <파인만 알고리즘>
    1. 문제를 적는다. ( 문제를 확실히 인지한다.)
    2. 생각한다.
    3. 답을 적는다. (풀이에 성공했으면 체계적으로 정리하고 저장한다.)


    <파인만 알고리즘을 통한 알고리즘 풀이에 중요한 단계적 요소>
    1. 문제를 읽고 이해한다.
        1. 문제를 꼼꼼히 읽어야한다.
        2. 제한조건도 잘 기억해야한다.
        3. 문제를 이해하는데 조급해서는 안된다.
    2. 문제를 익숙한 용어로 재정의한다.
        1. 문제를 자신만의 개념으로 재정리해서 직관적으로 기억해야한다.
        2. 현실의 복잡성을 정리해서 버리고 최대한 추상화시켜서 현실의 본질만 남겨놔야한다.
        (추상화를 시켜야 문제해결 도구를 적용시켜서 문제를 해결할 수 있다.)
        3. 추상화를 어떻게 시키느냐에 따라 문제의 쉽고 어려움이 달라진다.
    3. 어떻게 해결할지 계획을 세운다.
        1. 문제를 어떻게 해결할지 결정
        2. 사용할 알고리즘 선택
        3. 자료구조 선택
        4. 가장 오래 걸리는 단계
    4. 계획을 검증한다.
        1. 올바른 정답을 도출하는지
        2. 시간 및 메모리제한을 충족하는지
        3. 알고리즘의 효율성과 정당성 증명
    5. 프로그램으로 구현한다.
        1. 코딩으로 구현
        2. 아무리 좋은 알고리즘이라도 제대로 구현하지 못하면 쓸 수 없음
        3. 코딩 기술이 중요한 이유는 이런 이유때문임
    6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.
        1. 장기적으로 영향을 미치는 단계
        2. 문제를 반복해서 풀어봐야함
        3. 어떤 방식으로 접근했는지 회고해야함
        4. 결정적인 문제의 단서가 되었던 점을 기록
        5. 오답의 원인기록
        6. 다른 사람의 여러가지 다른 방법을 찾아보기



    <문제를 풀지 못했을 때>
    1. 일정 시간이 지나면 풀이를 참조한다.
    2. 다른 사람의 풀이를 보면서 나는 왜 이 풀이를 떠올리지 못했는지 원인 파악
    3. 요약 정리 및 반복 


    문제해결 전략
    <직관과 체계적인 접근>
    1. 직관적으로 문제를 분석하고 큰 그림이 머리 속에 그려지는 것
    2. 직관이란 결국 많은 문제를 풀면서 차곡차곡 머리 속에 쌓여지는 것
    


    <체계적인 접근을 위한 질문들>
    1. 비슷한 문제를 풀어 본 적이 있는가?
        1. 문제 풀이에 사용되는 기초 알고리즘의 동작과정과 원리를 확실히 알고 변형할 수 있어야 한다.
        2. 문제의 유형을 파악한다. 각각의 알고리즘들이 어떤 문제유형에 적용되는지 외운다.
    2. 가장 단순하게 원초적으로 푸는 노가다성 알고리즘을 생각해보자.
        1. 가장 단순한 알고리즘
        2. 간단하게 풀 수 있는 문제를 너무 복잡하게 생각하는 것을 방지
        3. 단순한 방법은 알고리즘의 효율성의 기준을 정해주는 효과가 있다.
        4. 단순하고 무식하게 먼저 푸는 방법을 생각해보고 그 방법에서 효율성있는 방법을 하나씩 추가하는 방식으로 나아간다.
    3. 내가 문제를 푸는 과정을 수식화
        1. 문제를 풀다보면 점진적인 접근방식이 안통하고 아얘 새로운 방향에서 접근해야 풀리는 문제도 존재
        2. 그 중에 하나로 간단한 테스트 입력을 직접 넣어서 해결해보는 것 그리고 그 과정에서 간단한 공식을 찾아내는 것
    4. 문제를 단순화 하기
        1. 문제를 좀 더 간단하게 만들어서 풀어보기
            1. 문제의 제약조건을 제거하고 풀어보기
            2. 계산하는 변수의 수를 줄이고 풀어보기
            3. 다차원의 문제를 1차원으로 줄여서 표현하기
            4. 꼭 문제해결의 실마리를 제공하지 않아도 문제를 직관적으로 이해할 수 있도록 도와준다
    5. 그림으로 그려보기
        1. 2차원 좌표로 바꿔서 기하학모형을 만들어서 풀어보기
    6. 문제를 바로 수식화하기 
        1. 수식화해서 수학적 기술을 사용해서 문제의 실마리를 얻기
    7. 문제를 분해하기
        1. 복잡한 제약 조건은 단순한 제약조건 여러개로 분해하기
    8. 뒤에서 부터 생각해서 문제를 풀기
        1. 문제에 내재된 순서를 거꾸로할경우 쉬워지는 경우가 있다. (사다리타기 같은 경우)
    9. 순서 뒤집기
        1. 순서를 강제하기
            1. 문제에서는 어떤 행위에 대해 순서가 있든 없든 상관이 없다면 내가 생각하기 쉽게 순서를 강제하는 것
            2. 경우이 수를 찾는 문제에 대해서 순서강제하기가 좋은 기술이 될 수 있다. 
                1. 같은 행위인데 경우의 수가 중복되어 여러개일때, 순서를 강제하면서 생각하면 편하다.
    10. 특정형태의 답만 고려해서 후보군을 줄여버리기
        1. 정규화 과정 : 무한개의 후보군 중에서 유한한 부분 집합만을 고려할 수 있는지 찾는다.
        2. 문제마다 어떤 정규화 기법을 사용해야할지 매우 다르기 때문에 많은 문제를 풀면서 경험을 쌓아야한다.
    

    < 코딩 짜는 원칙 >

    1. 간결한 코드
        1. 오타나 단순 버그 확률 감소
        2. 디버깅 쉬워짐
        3. 전역변수는 일반적인 실무에서는 최소화하는게 원칙 그러나 알고리즘에서는 많이 사용함
    2. 적극적인 코드 재사용
        1. 반복해서 사용하는 코드는 함수화 시킬 것
        2. 그러나 알고리즘 대회에서는 사실 이게 쉽지 않음 대부분의 코드의 용도가 하나뿐이라, 재사용하기 쉽지 않음. 
        3. 또한 실무에서 함수는 한가지 일만 하도록 작성해야 하지만 알고리즘대회에서는 시간때문에 그럴 수 없음.
    3. 표준 라이브러리 공부하기
        1. 기본적인 자료구조인 큐나 스택같은 것을 직접 짜서하는것은 시간낭비 표준라이브러리를 익히고 사용법도 익힐 것
        2. 문자열, 동적배열, 스택, 큐, 리스트, 딕셔너리 등의 자료구조 알아둘 것
        3. 정렬의 표준 알고리즘 알아둘 것
    4. 항상 같은 형태로 프로그램을 작성하기
        1. 알고리즘을 풀다보면 비슷한 형태의 함수를 여러번 작성하게되는데 이때 처음에는 다양한 방법으로 작성해보는게 학습에서 도움이 됨
        2. 그러나 점점 하면 할수록 최적화된 자신만의 한 가지 방법으로 정리해서 최대한 같은 기능에 대해서 같은 함수 하나를 쓰는게 디버깅과
        효율성에 시간을 빼앗기지 않아도 되므로 좋음.
    5. 일관적이고 명료한 명명법 사용
        1. 실무에서도 마찮가지로 모호한 변수명, 함수명 사용 금지 함수명은 특히 그 함수의 주된 일을 명명할 것
        2. 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익히기
    6. 모든 자료를 정규화해서 저장하기
        1. 같은 답인데 여러같이 표현이 있는 경우, 반드시 정규화를 해서 일정한 규칙으로 한가지의 표현법으로 리턴되게 함수를 짜야한다.
        2. 답은 같아도 표현법이 달라서 여러개가 나와버리면 디버깅이 힘들어진다. 
        3. 정규화는 자료를 입력 받거나, 계산하자마자 바로 이루어져야 좋다.
            1. 자료를 표현하는 클래서의 생성자에서 정규화를 수행하자 
            2. 외부에서 자료를 입력받자마자 수행하자
    7. 코드와 데이터를 분리시키기
        1. 자료구조를 사용해서 로직과 상관이 없는 데이터들은 배열이나 리스트를 만들어서 담아서 사용할 것
    


    < 흔히 하는 실수들 >
    1. 산술 오버플로
        1. 계산과정에서 변수의 표현범위를 벗어나는 값을 인지 못 할 경우가 많다.
        
    2. 배열 범위 밖 원소 접근
        1. 배열 크기를 정할 때 계산을 신중히 해야한다.
        2. 특히 0인덱스가 0부터 시작하는 점과 문제의 조건이나 어떤 자료의 반환이 1부터 시작되는 것으로 가정 될 때 

    3. 일관되지 않은 범위 표현 방식
        1. 같은 프로그램에서 범위를 표현하는 방식(부등호)이 일관성있지 않게 섞어쓰게되면 많이 햇갈려진다.
        2. 하나의 프로그램에 닫힌구간, 열린구간, 반열린 구간을 정해서 하나로만 쓸 것
            1. 닫힌구간 장단점 
                1. 공집함 표현이 힘들다.
            2. 열린구간 장단점
                1. 배열의 첫번째 요소를 포함시키기 위해서는 -1를 인덱스로 써야한다. 
            3. 반열린 구간
                1. A <= x < B 
                2. 배열의 범위 n개의 원소를 갖는 배열의 인덱스 범위  0 <= i < n
                3. 공집합 표현이 쉽다. 2<= i < 2  
                4. 어떤 두 구간(범위)이 연속해있는지 쉽게 알 수 있음  [a, b), [c, d) 일때 a == d or b == c 이면 연속된 구간이다.
                5. 구간의 크기를 쉽게 알 수 있다 [a, b)의 구간의 길이는 b-a 이다.
            4. 닫힌구간, 열린구간, 반열린 구간에서 
                1. a,b의 길이 [a, b] : b-a+1 [a, b) : b-a  (a, b) : b-a-1  생각하지 말고 외워라 
                2. 배열 a에서 0인덱스 부터 n개까지의 원소들의 평균을 구하는 함수가 있다하면
                함수(0, 끝인덱스) 일때 끝인덱스를 n으로 표현 할 때 
                반열린 구간으로 줄 때 : 0, n
                닫힌 구간으로 줄 때 : 0, n-1
                열린 구간으로 줄 때 : -1, n 인데 배열인덱스에서 -1은 없으므로 생각하지 않음.
                반열린 구간에서 7번째 인덱스는 n이다.
                    (이유는 원래 인덱스는 갯수에 비해 -1인데, 여기서 배열의 끝인덱스가 열린 범위이므로 다시 +1를 해줘야해서 그냥 n)
                닫힌 구간에서 7번째 인덱스는 n-1이다. 
                    (이유는 원래 갯수에 비해 -1적은게 인덱스이므로, 0부터 8번째는 0부터 7까지의 인덱스이다. )
   
    4. Off-by-one 오류
        1. 계산의 로직은 맞지만, 계산시 1이 많거나 1이 부족해서 1차이로 답이 틀리는 오류를 말한다.
        2. 의외로 생활속에서도 이런 실수가 많다. 100m에서 10m간격으로 가로등을 설치한다고 했을때 필요한 가로등 숫자는? 10개가 아니라 11개다.
        3. 정수배열 A[i] 부터 A[j] 까지 평균을 구한다고 할 때 나눠야하는 n은 j-i+1이다. 
        4. 이런 실수를 피하는 방법 중 하나로, 가장 최소입력을 가정하고 계산해보는 것이다. 
            1. 가로등은 0m를 가더라도 1개는 박아야한다. 
            2. A[2] 부터 A[2] 까지 평균은 2-2 = 0 으로 나누는게 아니라 2-2+1 = 1로 나눠야 한다. 

    5. 컴파일러가 잡아주지 못하는 상수 오타
        1. 데이터를 별도로 빼서 프로그래밍할때, 그것 자체는 좋으나, 데이터 입력시 스펠링이 틀리거나하면 디버깅하기가 불가능하다.
        2. 출력할 문자를 그냥 잘못 쓴느 경우
        3. 큰수의 상수를 표현할때, 10000000003 같은 경우 0의 갯수를 틀려서 오류가 발생
        4. 데이터 타입 오류 특히 정수/상수/실수에 대해서 언어마다 타입별로 오버플로우가 발생할 수 있음

    6. 스택 오버플로 
        1. call stack이 오버플로해서 프로그램이 강제종료되는 현상
        2. 대개 재귀 호출의 깊이가 너무 깊어져서 온다.
        3. 재귀 호출을 사용할 일이 굉장히 많다. 
        4. 언어마다 배열 지역변수를 스택에 저장하는 것이 있는데, 이럴 경우 재귀 호출이 몇 번 일어나도 스택 오버플로가 나기 쉽다.
        5. 그래서 지역변수보다 전역변수를 자주 사용하는 것이다.(알고리즘 대회일 경우)
        6. 아니면 힙의 저장공간을 사용하는 툴 STL 컨테이너를 사용하기도 한다.

    7. 다차원 배열 인덱스 순서 바꿔 쓰기
        1. 실무에서는 2차원 배열 이상 쓰기가 드믈지만 알고리즘에서는 자주 일어난다.
        2. 그러나 이런 다차원배열을 다룰 때 특히 인덱스의 순서가 햇갈리는 경우가 있다.
        3. 동적 계획법을 위한 메모이제이션 패턴을 사용할 때 이런 일이 잦다.
        4. 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋다.

    8. 잘못된 비교 함수 작성 
        1. c++ 표준 라이브러리에서는 비교함수가 < 연산자와 같은 방식으로 동작한다고 가정함
        2. 그로인해 < 연산자를 오버로딩해서 비교함수를 작성할 경우 제대로 동작하지 않는 경우가 있음
        3. 연산자의 법칙을 이해하고 비교함수를 작성해야함
            1. a < a 항상 거짓 (비반사성 : irreflexivity )
            2. a < b 가 참이면 b < a 는 거짓 (비대칭성 : asymmetry)
            3. a < b 가 참이고, b < c 가 참이면 a < c 이다. (전이성 : transitivity)
            4. a < b 와 b < a가 모두 거짓이면 a와 b는 같은 값으로 간주한다. a = b, b = c 이면 a = c 이다 (상등관계의 전이성 : transitivity of equivalence)
        4. 언어마다 비교 함수의 모델로 쓰이는 연산자가 다르다 자바는 <= 이고 c++ 은 < 이다.            
    
    9. 최소, 최대 예외 잘못 다루기
        1. 문제 중에서는 최대값과 최소값의 입력에 대하여 예외가 되는 경우가 생각보다 많다.
        2. 코드를 짤 때 최소값과 최대값 입력에 대하여 잘 동작하는지 생각해보는게 좋다.
        3. 1 % 2 = 무엇이 나올지 예상해보기 (자바스크립트에서 나머지연산자는 모든 숫자를 정수 취급한다. )
        4. 로직상에 문제. 내가 만든 로직의 헛점으로 예를 들어 0이나 1를 입력하면 다르게 나오는 경우들 이런것들이 찾기 힘들다.

    10. 연산자 우선순위 잘못쓰기
        1. 사칙연산은 외우고있기때문에 걱정없으나 비트연산자 시프트 연산자 우선순위는 잘 모른다.
        2. 그렇기 때문에 순서 규칙을 외우거나, 햇갈리면 가로를 이용해서 항상 먼저 계산 되어야 하는 것을 확실히 해두자

    11. 입력 / 출력 방식에 있어서 특히 문자열 언어마다 저수준 입출력방식을 택해야 할 경우가 있다.
        1. 입출력 인자가 만개이상 넘어갈 때
        2. 고수준 입출력방식과 저수준입출력방식 모두 사용 할 줄 알아야한다.

    12. 변수 초기화 문제
        1. 알고리즘 문제는 예제를 많이 넣어서 돌려보고 정답이 경우 정답으로 친다. 
        2. 만약 초기화 과정이 없다면 로직은 맞아도 틀리게 나올 수 있다. 
        3. 대부분 정답검사 과정에서 틀리게 검출되지만 간혹 운이 안좋으면 검출이 안될때가 있다. 
            1. 예제 테스트는 작은 수부터 큰수 차례대로 입력해서 확인하는 방식이다
            2. 근데 초기화를 하지 않았고,
            3. 이 로직의 문제는 이전 값보다 더 작은 값을 입력하게 되면 의도치않은 문제를 일으키게된다.
            4. 이런 경우 어디가 문제인지 찾기가 힘들어진다. 
            5. 그러니 걍 변수는 항상 초기화를 하는 습관을 들이자 실무에서도 좋다.
    

    < 디버깅과 테스팅 >

    1. 디버깅에 대하여
        1. 알고리즘 문제는 코드 길이가 짧아 눈으로 디버깅하는 경우가 더 빠를 경우가 많다.
        2. 재귀호출이나 중복 반복문을 많이 사용하는 복잡한 코드는 디버거로 디버깅하기가 쉽지않다.
        3. 대회 규칙상 컴퓨터가 그리 좋지 않아서 걍 머리로 하는게 더 이득이다.
        4. 그냥 내 눈과 머리로 디버깅을 하는 습관을 들이자.
   
    2. 디버깅이 쉽도록 애초에 코드를 가독성 좋게 짜자
        1. 이런 습관은 실무에서도 매우 중요하다. 
        2. 기능적으로 잘 분리해서 함수를 짜자
    
    3. 머리로 디버깅하기 실전 기술
        1. 작은 입력에 대해 제대로 실행되나 확인
            1. 큰 입력의 경우보다 최대한 오류가나는 최소한의 입력으로 생각하는게 훨씬 편하다.
        2. 단정문(assertion)을 쓴다.
            1. 단정문이란 주어진 조건이 거짓이면 오류를 내고 강제 종료시키는 함수 또는 구문이다.
            2. 거짓일때만 오류를 내므로, 프로그램의 내부 상태를 검증할 때 유용하게 쓸 수 있다.
            3. 함수에서 넘겨받은 인자들이 정상적인 범위 안에 있는지, 값들은 제대로 입력 받았는지 확인할때 주로 쓰면 좋다.
        3. 프로그램 계산 중간 결과를 출력한다. 
            1. 자신의 예상대로 돌아가는지 중간 중간 결과값을 출력해본다.
            2. 기능 하나당 한번씩 출력해보자
   
    4. 디버거를 사용해야하는 경우
        1. 내 머리로 디버깅을 해도 뭔지 모를 때
        2. 런타임 오류는 실제 컴파일에서 보내주는 오류메시지를 읽어야 좋다.
        3. 언어마다 런타임 오류를 잘 보여주지 않는 경우 더버깅을 통해 오류메시지를 읽어보는게 좋다.



    
    < 테스트하기 > 

    1. 자신이 만든 프로그램에 제출 직전에 당연히 예제를 넣어서 테스트해야한다.
    2. 있을 수 있는 최소값/최대값을 만들어 시간내에 실행되는지 답이 맞는지 입력해본다.
    3. 스캐폴딩 (scaffolding)
        1. 루비온래이즈에서 나온 언어로, 웹개발시에 디비를 쉽게 조작할수 있게 해줘서 프로그램의 문제가 있는지 없는지 빠르게 작동시켜보게해준다.
        2. 뼈대를 미리 만들어 놓는다. 라는 의미로 받아들이면 된다.(실제로 건축에서 사용하던 용어다.)
        3. 스캐폴딩으로 코드의 정당성이나 반례를 찾는데 사용한다.
        4. 입력자료를 자동으로 생성해 자동으로 입력하여 테스트하는 테스트코드를 짜는 연습도 해야한다.
        5. 안그래도 시간이 부족한 알고리즘 대회에서 스캐폴딩까지 코드를 작성하여 테스트하는건 힘들다. 
            1. 그래서 미리 문제나 로직의 형태에 따라 이건 꼭 스캐폴딩이 필요하다 싶은것은 미리 작성하여 외워서 필요할때마다 쓰자.
    
    

    
    < 변수 범위의 이해 >
    
    1. 산술 오버플로
        1. 변수의 크기는 제한되어 있다는 점을 항상 기억해라. 
            1. 수학적/논리적으로 완벽한 알고리즘도 코딩에서는 다르게 나올때가 있음을 명심해라.
            2. 그중 산술 오버플로우로 인한 경우가 그나마 가장 흔하다.
            3. 대부분의 언어들이 계산 도중 오버플로가 일어나도 경고를 해주지 않는다. (연산을 할 때 마다 오버플로우를 확인하는게 매우 비효율적이기때문)
            4. 로직에만 집중하여 문제를 풀다보니깐 아무래도 이런곳에서 나는 실수를 인지 못할 때가 훨씬 많다.
            5. 참고로 값이 너무 작아서 타입의 크기를 벗어나는 경우도 똑같이 오버플로우라고 명명한다.
                (언더 플로우라는 현상은 이와는 다른 현상이다.)
    
    2. 너무 큰 결과
        1. 자바스크립트에서는 걱정하지 않아도 될 문제인데, double 타입을 쓰는데 계산 중간에 int 타입을 쓰게되는 경우가 있다.
        2. 32비트 정수 64비트 정수 표현이 계산이나 로직 중간중간에 일관성있지 못하게 바뀌는 경우가 매우 흔하므로 주의하자.
        (로직에 집중하다보면 사소한 곳에서 나도 모르게 타입이 바뀔 수 있다.)
    
    3. 너무 큰 중간 값
        1. 참고로 32비트 정수 최대 수는 약 21억이다.
        2. 문제를 푸는데 있어서 얼핏보면 입력도 32비트 정수 출력도 32비트 정수라 방심할때가 있다. 
        3. 계산 도중에 32비트를 넘기는 경우가 있다. 
        4. 코드의 논리를 검사하는 경우에는 이런 실수를 놓치기 쉽다.
    
    4. 무한대값을 이용할 때
        1. 문제를 풀다보면 '무한대'를 이용해서 푸는게 편할때가 있다.
        2. 예를 들면 최단거리를 찾는 문제에서 만약 길이 없는 경우의 수는 제외를 해야한다면, 길이 없는 경우에는 길의 길이를 무한대로 넣어서
        자동으로 min()함수에 의해서 걸러지는 것으로 예외처리를 쉽게 처리할 수 있다.
        3. 그런데 이때 흔히 하는 실수가 있다.
            1. 무한대를 실제로 타입변수에 담을수는 없다 그래서 우리는 흔히 무한대를 표현하기 위해 해당 타입의 가장 큰 수를 무한대라고 치고 담는다.
            2. 이때 실수가 흔히 발생하게된다. 그 무한대라고 친 수에 연산과정에 있어서 1이라도 더해지는 경우, 오버플로가 일어나서 음수값을 출력하고만다.
            3. 그러면 min() 함수에 의해서 내가 배제할려고 했던 경우의 수가 가장 최소값으로 선정될 수 있다.
            4. 따라서 32비트 최대 정수는 그냥 987,654,321를 이용하자 외우기도 싶고 서로 더해져도 32비트 정수를 넘지 않는다.
            
    5. 오버플로 피해가기
        1. 가장 간단한 방법 : 더 큰 타입을 사용하는 것
        2. 문제에 따라 연산 순서를 다르게 해서 피해가는 방법
        3. 64비트 정수도 넘어가는 너무 큰수가 계산식에 포함될 때 
            1. 예를 들어 30! 는 졸라 큰수라 64비트 정수도 넘는다.
            2. 예를 들면 이항계수 계산이다.
                1. nCr = 이항계수 = n!/(n-r)!r! 인데 
                2. 점화식을 사용하면 계산과정에서 n! 를 계산하지 않아도 된다.
                3. n-1Cr-1 + n-1Cr  = nCr 이다. 이 점화식을 사용하면 32비트 정수로만 이항계수를 계산할 수 있다.
                4. 동적 계획법에서 이항계수를 빠르게 계산하는 방법이 있다.
            
    6. 자료형의 프로모션
        1. 연산자가 2개의 피연산자를 연산할 때 서로 타입이 다르면 컴파일러가 자동으로 형변환을 하는 것은 프로모션이라고 한다.
        2. 이 프로모션 과정중에 문제가 생기면 오류를 찾기가 굉장히 힘들다. 내가 의도해서 형변환을 한것도 아니기 때문이다.
        3. 조심해도 흔하게 실수하는 경우는 부호가있는 정수와 부호가 없는 정수와의 연산이다.
            1. C++에서는 부호 인트와 부호가 없는 Unsigned int 와 연산하면 그 답도 Unsigned int 로 다 변환되는데, 이과정에서 
            부호가있는 음수가 들어가게되면 오버플로가 일어나 강제로 부호가 없는 숫자로 강제 캐스팅되면서 매우 큰수로 바뀌게된다.
            2. 근데 자바나 C#, 자바스크립트는 이런문제를 걱정하지 않아도 된다.
    
    7. 실수 자료형의 이해
        1. 컴퓨터의 모든 실수변수는 정확도가 제한된 근사값을 저장한다.
        2. 따라서 위의 문제로 실수를 다룰 때 예상치못한 일이 일어난다.
        3. 따라서 컴퓨터가 실수를 어떻게 다루는지 원리를 이해해야 한다.
            1. IEEE 754 표준사용 
                1. 이진수로 실수를 표기함
                2. 부동 소수점 표기법
                3. 무한대, 비정규 수(NaN) 등의 특수한 값 추가
            2. 실수의 이진법 표기
                1. 십진수에서 소수점 밑의 수는 1/10의i승이다. 여기서 i는 소수점 밑 자리수이다. 
                2. 마찮가지로 이진수에서도 1011.01의 소수점 첫 자리는 1/2의1승 두번째 자리는 1/2의2승이다.
                3. 1011은 2의3승 + 2의2승 + 2의 1승 + 2의 0승 이다. 
            3. 부동 소수점 표기
                1. 실수의 표현을 최대한 효율적으로 하기 위해 부동소수점 방법을 만들었다.
                2. 소수점이 마음대로 움직이면서 숫자를 표현할 수 있는 방법이다.
                3. 그래서 수를 표현하는데 다음과 같은 원리가 있다.
                    1. 부호비트 (sign bit): 양수인지 음수인지 여부
                    2. 지수(exponent) : 소수점을 몇 칸 옮겼나
                    3. 가수(mantissa) : 소수점을 옮긴 실수의 최상위 x 비트
                4. 가수부로 할당되는 비트수가 너무 적게되면 숫자의 정확도가 떨어진다.
                5. 그래서 과학자들은 지수부보단 가수부에 비트를 좀 더 할당하기로 결정한다.
                6. 실수를 사용한다면 일단 32비트는 마음속에서 지우고 64비트 실수형을 쓰기로 하자
                7. 64비트 실수형의 부동소수점 구조는 이렇다.
                    1. 부호비트 : 1
                    2. 지수비트 : 11
                    3. 가수비트 : 52
                    4. 총 64비트 사용
                    5. 참고로 8비트가 1바이트이다.
                    6. 음의 지수는 분수를 의미한다. 
        4. 실수 비교하기 
            1. 이진법으로 표기할 수 없는 형태의 실수는 정확한 값이 아니라 근사값으로 저장된다.
            2. 이로 인해 생기는 작은 차이가 결국 연산의 결과가 다르게 나오게 한다.
            3. 따라서 실수 값이 같은지 누가 더 큰지 비교할 때는 오차를 염두해야 한다.
            (1/10 과 3/10를 이진수로 바꿔 저장할때 모두다 정확하게 담지 못한다. 따라서 둘 다 근사치로 저장하게된다.)
            (따라서 1/10 * 3 === 3/10 은 false로 나오게 된다. )
            4. 따라서 두 실수의 차이가 매우 작은 경우 그냥 두 수를 같다고 따로 코딩을 해줘야 이런 오류를 피할 수 있다.
            5. 실수의 크기가 너무 크면 클수록 오차의 크기도 같이 커진다. (오차의 범위가 커진다.)
            6. 그래서 비교할 실수의 크기들에 비례해 오차 한도를 정해야한다.p79
                1. 큰수는 오차의 범위도 크게
                2. 작은 수는 오차의 범위도 최대한 작게
                3. 같다고 판단해야 할 경우 오차가 좀 있더라도 같다고 판단할 수 있는 만큼 수가 커야한다.
                    1. 같다고 판단해야 할 아주 큰 수 a, b 
                    2. 오차 한도 값이 항상 |a-b| 보다 커야한다. 이것 보다 크면 a,b는 같은수라고 봐도 된다.
                    3. 따라서 |a-b|의 최대치를 구해내는게 관건이다.
                4. 다르다고 판단해야 할 경우 오차가 있더라도 다르다고 판단할 수 있는 만큼 수가 작아야 한다. 
                    1. 

 








*/