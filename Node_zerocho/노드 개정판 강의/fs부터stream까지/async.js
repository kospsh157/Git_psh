const fs = require('fs');

console.log('시작');
fs.readFile('./readme2.txt', (err, data) => {
    if(err){
        throw err;
    }
    console.log('1번', data.toString());
});

fs.readFile('./readme2.txt', (err, data) => {
    if(err){
        throw err;
    }
    console.log('2번', data.toString());
});

fs.readFile('./readme2.txt', (err, data) => {
    if(err){
        throw err;
    }
    console.log('3번', data.toString());
});
console.log('끝');

// 시작과 끝을 제외하고는 결과의 순서가 계속 다르게 나오는 것을 알 수 있다.
// 비동기 메서드들은 백그라운드에 해당 파일을 읽으라고만 요청하고 다음 작업으로 넘어간다.
// 따라서 읽기 요청만 3번 보내고 console.log를 찍는다.
// 나중에 읽기가 완료되면 백그라운드가 다시 메인쓰레드에 알리고, 메인 스레드는 그제서야 등록된 콜백함수를 실행한다.
// 즉 요청을 계속 얼마든지 보낼 수 있고, 백그라운드가 작업을 완료하면 그때 콜백 함수를 처리하는 것이다.

// 동기와 비동기, 블로킹과 논 블로킹
// 동기와 비동기 : 백그라운드 작업 완료 확인 여부
// 블로킹과 논블로킹 : 함수가 바로 return 되는지 여부
// 노드에서는 대부분 동기-블록킹 이거나, 비동기-논블록킹 방식이 대부분이다. 그 외는 거의 없다고 봐도 좋다.

// 동기-블록킹 방식에서는 백그라운드 작업완료 여부를 계속 확인하면서 호출한 함수가 바로 return되지 않고 백그라운드 작업이 
// 끝나야 return 된다.

// 비동기-논블록킹 방식에서는 백그라운드 작업완료 여부를 확인하지 않고, 호출한 함수는 바로 return되어서 다음 작업으로 넘어간다. 
// 백그라운드에서 알림을 주면 그때서야 처리한다. 

// 비동기-논블록킹 방식은 함수가 호출되면 바로 return 하고 다음 작업으로 넘어가기 때문에 노드프로세서가 기달리지 않고 바로 다음
// 일을 수행한다. 그리고 백그라운드가 일을 다 하면 그때 알림을 주고 그제서야 콜백함수를 실행하는 방식인 것이다.

