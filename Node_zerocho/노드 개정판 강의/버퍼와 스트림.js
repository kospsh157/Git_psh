// 버퍼와 스트리밍
/*
    1. 버퍼 : 일정량 용량까지 차면 그때서야 클라이언트에게 데이터를 보냄
    2. 스트리밍 : 버퍼가 스트리밍의 부분집합이라고 볼수도 있음. 
    스트리밍은 일정 용량이 차면 바로바로 클라이언트로 데이터를 보냄
    3. 중요한 차이점 : 
    버퍼는 조각조각 난 청크들을 동시에 보내줘도 상관은 없음
    그러나 스트리밍은 순서대로 보내줘야함 동영상을 스트리밍을 시청할 때를 생각하면 됨
    데이터는 반드시 순서를 지켜서 보내줘야 받는 쪽에서 영상을 제대로 볼 수 있음.

    버퍼와 스트리밍의 차이점은 스트리밍은 바로바로 데이터를 전송한다는 것과
    버퍼는 일정용량이 찰 때까지 기다렸다가 데이터를 보낸다는 점 

    스트리밍 서버 : 대용량 데이터를 보내기위해서 효율이 좋은것은 스트리밍 방식이다.
    그 이유는 버퍼방식인 경우 반드시 버퍼용량만큼 데이터를 채워야 한다. 그리고 데이터가 너무 큰 경우 버퍼에 다 못 담기 때문에
    어차피 쪼개야 한다. 
    스트리밍 서버는 데이터가 아무리 커도 잘개 쪼개서 하나씩 순서대로 보내면 된다. 

    버퍼방식의 서버는 100기가 짜리 데이터를 보내려면 100기가의 메모리가 필요하다
    그러나 스트리밍 서버는 100기가 짜리든 뭐든 청크 단위의 메모리만 있으면 나눠서 보내는게 가능하다. 



    참고로 나눠진 데이터 덩어리를 chunk라고 한다.
    
*/

// 버퍼와 스트리밍 방식으로 코드를 짜보자
// 먼저 버퍼
const buffer = Buffer.from("한글이 좋아 세종대왕님"); 

console.log(buffer);                // 16진수로 나온다.
console.log(buffer.toString());     // 정상적인 문자열 형태로 출력 
console.log(buffer.length);         // 비트의 길이를 나타낸다. 

// 버퍼는 특성상 쪼개지는 경우가 많다. 쪼개서 보내서 받는 쪽이 일정용량이 될 때 까지 모아서 다시 합친다. 
// 이 과정의 반복이다.
// 먼저 쪼개진 조각조각의 버퍼들이 배열에 있다고 하자
const arrBuffer = [Buffer.from("띄엄 "), Buffer.from("띄엄 "), Buffer.from("띄어쓰기")];
// 이걸 합쳐서 다시 문자열로 나타내면
console.log(Buffer.concat(arrBuffer).toString());

// 때로는 아무것도 들어있지 않은 버퍼데이터를 만들어야 할 경우가 있는데 이럴때는 다음 함수를 사용한다.
console.log(Buffer.alloc(5))         // 5바이트의 버퍼데이터가 생성된다.



// 스트리밍 간단 예제 코드 (참고로 버퍼방식의 경우 그냥 fs.readFile로 버퍼 사이즈에 맞게 다 오면 그냥 읽으면 된다.)

const fs = require('fs');
// 크리에잇 리드 스트림을 이용해서 먼저 보낼 데이터를 나눈다. 
// 하이워터마크는 임의로 청크들의 사이즈을 16바이트로 지정한것이다.
// readStream의 기본 청크 사이즈가 64kb 이다.
// 따라서 현재 용량이 너무 작아서 한번에 다 하기 때문에 일부러 청크사이즈를 확줄여서 확인해보는 예제인 것이다. 
const readStream = fs.createReadStream('./someThingRead.txt', {highWaterMark: 16});

// 받을 데이터를 공간을 배열로 만들자
const data = [];
// chunk가 서버로부터 오면 받는 쪽은 이렇게 배열에 차례대로 하나씩 담아서 완성시켜야 한다.
readStream.on('data', (chunk) => {
    data.push(chunk);
    // 받은 데이터를 하나씩 확인해보자 
    console.log('data', chunk, chunk.length);
});

readStream.on('end', () =>{
    // 이벤트에서 end 이므로 서버로부터 청크 데이터가 다왔을때의 이벤트 핸들러임을 알 수 있다.
    // 데이터가 다 왔으면 이제 합쳐야 한다.
    console.log('End', Buffer.concat(data).toString());
})

readStream.on('error', err => {
    // 리드 스트림도 다 비동기 방식이다. 에러는 잘 나지 않지만, 그래도 에러가 날 경우가 있으므로,
    // 항상 에러에 대해서도 핸들러를 만들어 줘야한다. 
    console.error('error : ', err);
})


// 이번에는 라이트 스트림으로 쓰기를 하는 간단 코드 예제
const fs = require('fs');
const writeStream = fs.createWriteStream('./writeText.txt') // 쓸 파일을 생성한다. 

writeStream.on('finish', () => {
    // 쓰기가 완료되면 불러지는 finish 핸들러
    console.log('파일쓰기완료');               // 받는 쪽이 모든 청크 데이터들을 다 받고 이 'finish' 이벤트가 호출된다.
})

writeStream.write('여기다가 글을 쓴다.\n');     // 이거 한 줄이 하나의 버퍼같은 곳이다.
writeStream.write('두 번째 청크에다 글을 쓴다');  // 받는쪽에서 'data' 이벤트와 연결된다.
writeStream.end()                           // 쓰기를 종료한다. 받는쪽의 'end' 이벤트와 연결된다.


