// 호출 스택과 백그라운드와 태스크큐와 이벤트루프 ( 여기서 호출스택은 메모리의 스택 메모리와는 조금 다르다.)
/*
    1. 일단 노드 프로세스가 하나 실행되면 호출 스택에 anonymous ( = 전역 컨텍스트) 함수가 무조건 먼저 쌓인다.
    (이 전역 컨텍스트 까지 실행되면 모든 프로세스가 종료되어 프로그램의 종료를 의미한다.) 
    2. 우선 순서대로 함수를 호출한다. 그리고 하나를 호출하면 바로 스택에서 실행된다. 
    (만약 호출된 함수가 다른 함수를 또 호출하는 함수라면 호출스택 위에 그대로 쌓이게된다. 다 쌓이면 그 후에 위에서부터
        함수들을 실행한다. )
    3. 만약에 호출스택에 비동기 함수가 호출되면, (일단 호출하면 무조건 호출스택에 쌓아진다.) 실행시 바로 실행되는게 아니라 일단
    백그라운드로 넘긴다. 그리고 호출스택에서 모든 함수가 호출되고 실행되고, 전역 컨텍스트까지 호출되어 호출스택이 빈상태가 된다.
    4. 그리고 백그라운드에 갔던 비동기함수는 태스크큐로 이동되고,(만약 타이머 함수이고, 3초 예약을 걸었다면, 백그라운드에서 3초를
        세고, 이후 태스크큐로 넘어간다.)호출스택이 비면, 
    5. 이벤트루프가 일을 할 차례인데, 호출스택이 비면, 태스크큐에 있는 함수들을 FIFO방식으로 호출스택으로 넘긴다.
    6. 그 다음 호출스택이 태스크큐로부터 넘겨받은 함수를 실행하고 종료된다.
    7. 따라서 자바스크립트의 프로그램의 최종 종료는 호출스택/백그라운드/태스크큐가 모두 비어 있어야 끝난것이다.
*/


// 백그라운드로 갈 수 있는 함수는 노드에서 정의되어 있다. 아무 함수나 백그라운드로 갈 수 없다. 
/*
    입출력/타이머/네트워크요청/암호화/압축 .. 이런 함수들만 백그라운드로 갈 수 있다.
    임의의 사용자 함수들은 모두 동기로 돌아간다. 
*/

// 다음 코드를 보면서 자바스크립트가 돌아가는 순서를 예상해보자
function oneMore(){
    console.log('one more');
}

function run(){
    console.log('run run');
    setTimeout(()=> {
        console.log('wow');
    },0);

    new Promise((resolve)=>{
        resolve('hi');
    }).then(console.log);

    oneMore();
}

setTimeout(run, 5000);

// 이벤트 루프가 태스크큐에 있는 함수들을 호출스택으로 보낼때, 규칙이 이다.
/*
    1. 일반적으로는 큐 순서에 따라 보낸다.
    2. 그러나 몇몇 함수들은 순서를 무시하고 호출 스택으로 가게된다. 
        1. Promise 의 then/catch 함수
        2. process.nextTick 함수 
    위의 코드에서도 그래서 then 함수의 콘솔로그가 먼저 실행되어서 hi가 wow 보다 먼저 호출된다.
    
*/


// 백그라운드 운영체제 쪽이다. 자바스크립트가 아니다. 호출스택만 자바스크립트이다. 
// 백그라운드랑 태스크큐는 Libuv 에서 c나 c++로 만들어져 있다.
// 그래서 백그라운드로 간 함수는 멀티 스레드처럼 호출스택에에 있는 함수와 같이 동시에 실행이 된다. 

// 노드에서 자바스크립트로 멀티 쓰레드를 돌릴려면 브라우저의 웹워커를 이용하거나, 노드14부터 추가된 워커쓰레드써야만
// 자바스크립트에서 멀티 쓰레드를 돌릴 수 있다. 





