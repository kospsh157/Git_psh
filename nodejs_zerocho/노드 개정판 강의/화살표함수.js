// function을 사용한 함수 선언 방식
function add1(x, y){
    return x + y;
}

// 위 함수를 화살표함수로 바꿔서 다시 선언해보면 
const add2 = (x, y) =>{
    return x + y;
}

const add3 = (x, y) => x + y;

const add4 = (x, y) => (x + y);
// 위의 함수 3개는 모두 동일한 함수이다.




// 주의할 점 1
// 주의할 점은 객체 리터럴 표현과 함수 바디의 중괄호를 생략하는 화살표함수의 경우 동시에 쓰이면 컴파일이 구분을 못한다.
const ex = (x, y) => {
    return {x, y};
}

// 위와 같은 함수일 때, 의도한 바로는 return 할 때 es6객체리터럴 표현을 사용해서 객체를 의미하는 바이다.
// 근데 화살표 함수에서 생략 규칙중에 함수 바디 중괄호 다음 바로 return이 오면 이 둘을 모두 생략해서 쓸 수 있는데 
// 위의 함수를 그 규칙에 의해 생략해보면 다음과 같다

const ex = (x, y) => {x, y};        // 이럴경우 {x, y} 가 객체 리터럴 표현인지, 아니면 함수바디 중괄호로 
                                    // 쓰인 것인지 컴파일러가 구분할 수 없다. 

// 따라서 이렇게 객체를 리턴하는 경우에는 소괄호로 감싸주는 것이 필수이다.
const ex = (x, y) => ({x, y});      // 이러면 확실히 객체를 리턴한다는 뜻으로 확실해 진다.


// 주의해야 할 점2
/*
    1. return 구문을 생략 할 수 있다. 함수 내용이 한줄일 경우.
    2. 따라서 return이 생략되어 없어진 것인지, 아님 원래 return이 없는 함수인지는 구분을 잘 해야 한다.

*/

const ex2 = (x) => {
    return x;
}
const ex2 = x => x;
// 위의 함수는 둘 다 같은 것지만, 

const ex3 = (x) => {
    x = 23;
}
const ex3 = x => x = 23;  
// 위의 함수 둘은 서로 다르다. 
// 함수 바디(중괄호) 를 생략했다는 것은 함수가 한 줄 이였다는 뜻이고, return을 생략 했다는 뜻이다. 

